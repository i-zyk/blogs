### 闭包作用域和浏览器垃圾回收机制

浏览器垃圾回收机制「GC」

+ 标记清除（webkit内核）
  + 当内存被占用时，浏览器会标记该内存被占用true；否则，被标记为false。当浏览器空闲时，会回收所有未被标记的内存。
+ 引用计数（IE低版本）
  + 当内存被引用时，浏览器会标记有几处引用（1,2，3，...）；否则为0。当浏览器空闲时，会回收所有为0的内存。
  + 
**• 总结：** 只要内存被占用，内存就不能被释放；如果没有被占用，浏览器空闲时就会释放。

**前端性能优化方案之：** 内存优化

释放一些没必要的内存空间，以此优化产品的运行速度

**堆内存：** 浏览器对于内存回收，有自己的处理方案「标记清除(谷歌) & 引用计数(IE)」，对于堆内存来讲，只要有其他事物占用这个堆内存「存储这个堆内存地址」，那么在浏览器空闲下来的时候，不会清除被占用的堆内存，但是会清除没被占用的堆内存！

手动解除占用：变量 = null

**栈内存：** 执行上下文

+ 全局上下文：

    打开页面，执行全局代码就会形成；只有当页面关闭的时候才会释放；

+ 私有上下文：

    一般函数(代码块)中的代码执行完，浏览器会自动把私有上下文出栈释放；但是如果，当前上下文中，某个和它关联的内容（一般指的是一个堆内存）被当前上下文以外的事物占用了，那么这个私有上下文不能出栈释放；这样私有上下文中的“私有变量/值”也被保存起来了! 闭包的机制:保护、保存

**闭包机制**    
@1 保证私有上下文中的私有变量和外界的变量没有任何的关系「保护功能」

@2 还可以把私有变量和对应的值保存起来，供其下级上下文使用「保存功能」

我们把函数执行的这种机制称之为"闭包"

**提问：什么是闭包**

闭包是一种保护和保存的机制，它的特点是当前函数执行产生私有上下文，如果当前这个私有上下文中，某个和它关联的内容，被当前上下文以外的事物「变量、事件绑定等等」占用了，那么不仅这个所关联的内容「堆内存」不能释放，并且当前的这个私有上下文也不能出栈释放；

我们把这种保护和保存的功能叫闭包，

保护：私有上下文中的变量和外界的变量没有关系，不受全局变量的污染

保存：所关联的内容和这个私有上下文不被释放，内容就被保存出来了

[图解](./Chapter-2/Item8/1.png)
[图解](./Chapter-2/Item8/2.png)


```
<!-- 
EC(G)
  AO(G)/GO
    fn -> 0x000 [[scope:EC(G)]]
    x -> 5
    f -> fn(6) -> 0x001

变量提升: function fn(x){...};
代码执行: 
-->

let x = 5;
function fn(x) {
    return function(y) {
        console.log(y + (++x));
    }
}
<!--
EC(FN1) -> fn(6)
  AO(FN1)
    x -> 6
  作用域链: <EC(FN1),EC(G)>
  this -> window
  形参赋值: x = 6
  变量提升: --
  代码执行：
    return function(y) {
        console.log(y + (++x));
    }; => 0x001;
 -->
let f = fn(6);
f(7);
fn(8)(9);
f(10);
console.log(x);

```

```
let a=0,
    b=0;
function A(a){
    A=function(b){
        alert(a+b++);
    };
    alert(a++);
}
A(1);
A(2);
```


